<!DOCTYPE html>
<meta name=viewport content="width=device-width, initial-scale=1" charset="utf-8">

<head>
<title>Foliation of D(x, y)</title>

</head>

<style>
#container {
  display: flex;
  flex-direction: row;
  text-decoration-thickness: 30px;
  
  
}

#sidebar {
  right: 0%;
  top:0%;
  margin: 20px 100px;
  position:absolute;
  display: flex;
  flex-direction:column;
}

.label {
  height: 40px;
  width: 300px;
  font-size: 24px;
  cursor: default;
  background-color: transparent;
  font-family: "Times New Roman", Times, serif;
}


.button:active{
  background-color: lightblue;
}

.label{
  border: RGB(230,230,230,0) 2px solid;
}

.label:hover{
  cursor: default;
}


.textBox {
  height: 40px;
  width: 300px;
  font-size: 24px;
  cursor: pointer;
  background-color: transparent;
  border: RGB(230,230,230) 2px solid;
  padding: 0 20px;
  margin: 0 0 30px 0;
  font-family: "Times New Roman", Times, serif;  
}

.textBox:hover {
  cursor: text;
}
#title {
  font-size: 30px;
  margin:  0 0 30px 0;
}


</style>

<body>
    <div id="container" style="margin-left: 20px;">
        <canvas id="canvas" width="850" height="700" style="border:1px solid steelblue;" onclick="activate()"></canvas> <!-- 650 -->
    </div>
    <div id = "sidebar">
      <div class="label" id="title"\>Foliation generator for dimple surfaces.</div>
      <div class="label"\></div>
      <div class="label"\>dimple(a, b):</div>
      <input id = 'dimpleOutput' type = "text" class="textBox" value = "2, 1" onkeypress="handleClick(event,'dimpleOutput')"\>
      <div class="label"\>trajectory vector:</div>
      <input id = 'stepOutput' type = "text" class="textBox" value = "" onkeypress="handleClick(event,'stepOutput')"\>
      <div class="label"\>slope:</div>
      <input id = 'slopeOutput' type = "text" class="textBox" value = "" onkeypress="handleClick(event,'slopeOutput')"\>
      <div class="label"\>'hopping' sequence:</div>
      <input id = 'hopOutput' type = "text" class="textBox" value = "" onkeypress="handleClick(event,'hopOutput')"\>
      <div class="label"\>cutting sequence:</div>
      <input id = 'homologyOutput' type = "text" class="textBox" value = "" onkeypress="handleClick(event,'homologyOutput')"\>
      <!-- <input type="checkbox" id="myCheck" onclick="myFunction()"> -->
    </div>
</body>

<script>



var colorList = ['#9FC5E8','#FFE599','#B4A7D6','#FFC4C4']



var domain = {
    canvasWidth : canvas.width,
    canvasHeight : canvas.height,
    endPoint : [0,0],
    initialBoxType : 0,
    initialBoxDim: [2,1],
    d: 20,
    active: true,
    allCircles : []
}



// console.log('---')
// console.log(domain.allCircles)
// console.log('---')

// ctx.clearRect(0, 0, canvas.width, canvas.height);


function makeGraph(domain){
  var stepOutputBox = document.getElementById("stepOutput")
  var slopeOutputBox = document.getElementById("slopeOutput")
  var hopOutputBox = document.getElementById("hopOutput")
  var homologyOutputBox = document.getElementById("homologyOutput")
  var c = document.getElementById("canvas");
  var ctx = c.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  var x0 = 0;
  var y0 = 0;
  var m1 = domain.endPoint[1]/domain.endPoint[0]
  var boxType = domain.initialBoxType;
  var scale = 1;
  var boxCount = 0;
  var d = domain.d
  var hoppingSequence = ''
  var homologyString = '';
  var homologyClass = [0,0];
  var scaleFactor = domain.initialBoxDim[0] / domain.initialBoxDim[1];
  var tracking = true;


  // hopOutputBox.style = ""

  while (x0 * d <= domain.endPoint[0] && y0 * d <= domain.endPoint[1] && boxCount < 200){
    boxCount += 1
    var dy = scale * domain.initialBoxDim[1]
    var dx = scale * domain.initialBoxDim[+!!boxType]
    var boxWidth = d * dx - 1;
    var boxHeight = d * dy * (-1) + 1;
    var y1 = y0 + dy;
    var x1 = x0 + dx;
    var near = Math.abs(y0 - m1 * x0) < .05;
    var closed = (boxType == domain.initialBoxType);

    ctx.fillStyle = colorList[boxType];
    ctx.fillRect(x0 * d, domain.canvasHeight - y0 * d, boxWidth, boxHeight);
    ctx.beginPath();
    ctx.moveTo(0, domain.canvasHeight);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.lineTo(domain.endPoint[0], domain.canvasHeight - domain.endPoint[1]);
    ctx.stroke();

    
    if (closed && near && tracking && y0){
      hoppingSequence += ',';
      ctx.beginPath();
      ctx.arc(x0 * d, domain.canvasHeight - y0 * d, 10, 0, 2 * Math.PI);
      ctx.fillStyle = "rgba(255, 255, 255,1)";
      ctx.strokeStyle = "rgba(0,0,0,1)";
      ctx.fill();
      ctx.stroke();
      tracking = false;
      hopOutputBox.style = "text-decoration-line: overline"
      // domain.allCircles.push([x0,y0])
      // domain.allCircles = domain.allCircles.filter(( t={}, a=> !(t[a]=a in t) ))
    }
    
    if (tracking){
      hoppingSequence += boxType.toString()
    }

    if (m1 > y1/x1){
      if (boxType == 0){scale *= scaleFactor}
      else if (boxType == 3) {scale /= scaleFactor;}
      y0 = y1;
      boxType = [3,2,1,0][boxType];
    }
    else{
      x0 = x1;
      boxType = [1,0,3,2][boxType];
    }
  }

  
  
  stepOutputBox.value = (domain.endPoint[0]/d).toString() + ', '+ (domain.endPoint[1]/d).toString()
  slopeOutputBox.value = (domain.endPoint[1]/domain.endPoint[0]).toString()
  hopOutputBox.value = hoppingSequence
  

  var noComma = hoppingSequence.replace(/,/g,'0')
  for (let i = 1; i < noComma.length; i++) {
    var pair = noComma[i-1] + noComma[i];

    // if (['10','23'].includes(pair)){
    //   homologyClass[0] += 1;
    //   homologyString += 'B'
    // } else if (['30','21'].includes(pair)){
    //   homologyClass[1] += 1;
    //   homologyString += 'A'
    // }

    if (['30','21'].includes(pair)){
      homologyClass[1] += 1;
      homologyString += 'A'
    } else if (['10','23'].includes(pair)){
      homologyClass[0] += 1;
      homologyString += 'B'
    }
  }
  homologyOutputBox.value = '(' + homologyClass.toString() + ')  =>  ' + homologyString;
  

  // for (circle of domain.allCircles) {
  //   console.log('here')
  //       ctx.beginPath();
  //       ctx.arc(circle[0] * d, domain.canvasHeight - circle[1] * d, 5, 0, 2 * Math.PI);
  //       ctx.fillStyle = "rgba(255, 255, 255,1)";
  //       ctx.strokeStyle = "rgba(0,0,0,0.5)";
  //       ctx.fill();
  //       ctx.stroke();
  //   }
}





canvas.addEventListener("mousemove",function(e){
  var rect = e.target.getBoundingClientRect();
  var x = Math.ceil(e.clientX - rect.left);
  var y = domain.canvasHeight - Math.ceil(e.clientY - rect.top);
  domain.endPoint = [x,y]
  if (domain.active){
    makeGraph(domain)
  }
})

function activate(){
  domain.active = !domain.active;
  if (domain.active){
    makeGraph(domain)
  }
}

function handleClick(e,buttonId){
  if(e.keyCode === 13) {
    var input = document.getElementById(buttonId).value;
    if (typeof eval(input) === "number"){
      if (buttonId == 'stepOutput'){
          val = input.replace(' ','').split(',')
          domain.endPoint = [eval(val[0]) * domain.d, eval(val[1]) * domain.d]
      }
      else if (buttonId == 'slopeOutput'){
          input = eval(input)
          // var target = Math.ceil((domain.canvasWidth ) / domain.d) * domain.d
          if (input > domain.canvasHeight/domain.canvasWidth){
            domain.endPoint = [domain.canvasHeight / input, domain.canvasHeight]
          } else {
            domain.endPoint = [domain.canvasWidth, domain.canvasWidth * input]
          }
      }
      else if (buttonId == 'dimpleOutput'){
          domain.initialBoxDim = input.replace(' ','').split(',')
      }
      makeGraph(domain);
      domain.active = false;
    }
  }
}





</script>